## f1

### 出力結果

A
B
C

### 理由

- 順番に then がチェーンされており、各処理が前の Promise の解決後に実行されるため。
- → 同期的に見えるが、Promise による「マイクロタスク」で順番が保証されている。

## f2

### 出力結果

A
C
B

### 理由

- 2つ目の .then() の中で return がないため、この then は即解決され、C が先に実行される。
- Promise の順序は「マイクロタスクキュー」に従う。

## f3

### 出力結果

C
A
Error: X

### 理由

- then 内の errX() が同期例外を投げるため、C のあとに A を出力し、次の then は飛ばされてエラー発生。
- try/catch では Promise 内の then 内例外は捕捉できない。

## f4

### 出力結果

A
B
100

### 理由

- Promise 内で順番通り A → B → 100 が出力される。
- マイクロタスクの順序に従う。

## f5

### 出力結果

B
A
40

### 理由

- then の引数が Promise になっており、入れ子構造のため内側の B が先に実行される。

- これにより A より先に B が出力される。

## f6

### 出力結果

A
B
C

### 理由

- 1つの Promise に複数の then を呼ぶと、それぞれが独立して順番通り実行される。

- 各 then は元の Promise の解決後に実行される。

## f7

### 出力結果

A
B
C

### 理由

- 解決済みの Promise に対して then を追加しても順序は保証される。
- マイクロタスクキューに追加され、前の then 完了後に実行。

## f8

### 出力結果

X
A

### 理由

- then 内で errX() が例外を投げ、catch で補足される。
- finally は catch 後に必ず実行される。

## f9

### 出力結果

Y
A

### 理由

- Promise 内で reject が発生し、catch で補足され順序通り A を出力。
- reject → catch → finally の順序。

## f10

### 出力結果

A
Error: Y

### 理由

- then 内で例外 errY() がスローされる。
- catch を使用していないため、未補足の例外としてプログラムが停止する。

## f11

### 出力結果

X

### 理由

new Promise 内で throw された例外は catch によって補足される。

以降の処理はなし。

## f12

### 出力結果

Error: X

### 理由

- setTimeout 内で throw された例外は、Promise チェーン外なので catch では補足されない。

- マクロタスクとして次のイベントループで実行される。
