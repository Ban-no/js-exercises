## 解答 8.3

### 1. 末尾再帰最適化が可能な理由

通常の再帰呼び出しでは、関数が自分自身を呼び出すたびに「戻ってきたときに続きの処理をするための情報（戻り番地やローカル変数など）」をスタックに積む必要がある。そのため、再帰が深くなるとスタックがあふれてしまう。

しかし **末尾再帰** の場合、再帰呼び出しの直後にもう処理が残っていない。つまり「戻ってきてもやることがない」ので、

- 新しいスタックフレームを作らず、
- 現在のスタックフレームをそのまま使って再帰先にジャンプ
  できる。これにより再帰がループのように動作し、スタックの深さが増えない＝スタックオーバーフローが防げる。これが **末尾呼び出し最適化（Tail Call Optimization, TCO）** という仕組み。

### 2. JavaScript での実装状況

ECMAScript 2015 (ES6) で **末尾呼び出し最適化** が仕様に盛り込まれたが、実際には主要ブラウザや Node.js では実装されていない。2025 年現在、公式に **末尾再帰最適化をサポートする JavaScript 処理系は存在しない**。

一時期、Safari (WebKit) が ES6 の TCO を実装していたが、その後削除された。そのため、提示された TypeScript Playground のコードを実行すると、JavaScript エンジン（V8, SpiderMonkey, JavaScriptCore いずれも）では `factorial(100000)` はスタックオーバーフローになる。

---

✅ まとめ:

- **理由**: 末尾再帰では呼び出し後に処理が残らないため、スタックフレームを再利用できる。
- **現状**: JavaScript の主要処理系では最適化は行われておらず、スタックオーバーフローは回避できない。
